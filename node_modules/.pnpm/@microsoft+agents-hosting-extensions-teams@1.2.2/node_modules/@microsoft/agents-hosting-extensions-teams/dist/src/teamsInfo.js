"use strict";
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TeamsInfo = void 0;
const agents_activity_1 = require("@microsoft/agents-activity");
const errorHelper_1 = require("./errorHelper");
const teamsConnectorClient_1 = require("./client/teamsConnectorClient");
const teamsChannelDataParser_1 = require("./activity-extensions/teamsChannelDataParser");
const agents_hosting_1 = require("@microsoft/agents-hosting");
/**
 * Provides utility methods for interacting with Microsoft Teams-specific features.
 * This class includes methods for retrieving team details, meeting information, sending messages,
 * and managing operations within the Teams environment.
 */
class TeamsInfo {
    /**
     * Gets the meeting participant information.
     *
     * @param {TurnContext} context - The turn context.
     * @param {string} [meetingId] - The meeting ID.
     * @param {string} [participantId] - The participant ID.
     * @param {string} [tenantId] - The tenant ID.
     * @returns {Promise<TeamsMeetingParticipant>} - The meeting participant information.
     */
    static async getMeetingParticipant(context, meetingId, participantId, tenantId) {
        var _a;
        if (!context) {
            throw agents_activity_1.ExceptionHelper.generateException(Error, errorHelper_1.Errors.ContextRequired);
        }
        const activity = context.activity;
        const teamsChannelData = (0, teamsChannelDataParser_1.parseTeamsChannelData)(context.activity.channelData); // teamsGetTeamMeetingInfo(activity)
        if (meetingId == null) {
            meetingId = (_a = teamsChannelData.meeting) === null || _a === void 0 ? void 0 : _a.id;
        }
        if (!meetingId) {
            throw agents_activity_1.ExceptionHelper.generateException(Error, errorHelper_1.Errors.MeetingIdRequired);
        }
        if (participantId == null) {
            const from = activity.from;
            participantId = from === null || from === void 0 ? void 0 : from.aadObjectId;
        }
        if (!participantId) {
            throw agents_activity_1.ExceptionHelper.generateException(Error, errorHelper_1.Errors.ParticipantIdRequired);
        }
        if (tenantId === undefined) {
            const tenant = teamsChannelData.tenant; // teamsGetTenant(activity)
            tenantId = tenant === null || tenant === void 0 ? void 0 : tenant.id;
        }
        // return this.getTeamsConnectorClient(context).teams.fetchMeetingParticipant(meetingId, participantId, { tenantId })
        const res = await this.getRestClient(context).fetchMeetingParticipant(meetingId, participantId, tenantId);
        return res;
    }
    /**
     * Gets the meeting information.
     *
     * @param {TurnContext} context - The turn context.
     * @param {string} [meetingId] - The meeting ID.
     * @returns {Promise<MeetingInfo>} - The meeting information.
     */
    static async getMeetingInfo(context, meetingId) {
        var _a;
        if (!meetingId) {
            const teamsChannelData = (0, teamsChannelDataParser_1.parseTeamsChannelData)(context.activity.channelData);
            meetingId = (_a = teamsChannelData.meeting) === null || _a === void 0 ? void 0 : _a.id;
        }
        const res = await this.getRestClient(context).fetchMeetingInfo(meetingId);
        return res;
    }
    /**
     * Gets the team details.
     *
     * @param {TurnContext} context - The turn context.
     * @param {string} [teamId] - The team ID.
     * @returns {Promise<TeamDetails>} - The team details.
     */
    static async getTeamDetails(context, teamId) {
        var _a;
        if (!teamId) {
            const teamsChannelData = (0, teamsChannelDataParser_1.parseTeamsChannelData)(context.activity.channelData);
            teamId = (_a = teamsChannelData.team) === null || _a === void 0 ? void 0 : _a.id;
        }
        if (!teamId) {
            throw agents_activity_1.ExceptionHelper.generateException(Error, errorHelper_1.Errors.TeamIdRequired);
        }
        const res = await this.getRestClient(context).fetchTeamDetails(teamId);
        return res;
    }
    /**
     * Sends a message to a Teams channel.
     *
     * @param {TurnContext} context - The turn context.
     * @param {Activity} activity - The activity to send.
     * @param {string} teamsChannelId - The Teams channel ID.
     * @param {string} [appId] - The application ID.
     * @returns {Promise<[ConversationReference, string]>} - The conversation reference and new activity ID.
     */
    static async sendMessageToTeamsChannel(context, activity, teamsChannelId, appId) {
        if (!context) {
            throw agents_activity_1.ExceptionHelper.generateException(Error, errorHelper_1.Errors.TurnContextCannotBeNull);
        }
        if (!activity) {
            throw agents_activity_1.ExceptionHelper.generateException(Error, errorHelper_1.Errors.ActivityCannotBeNull);
        }
        if (!teamsChannelId) {
            throw agents_activity_1.ExceptionHelper.generateException(Error, errorHelper_1.Errors.TeamsChannelIdRequired);
        }
        const convoParams = {
            isGroup: true,
            channelData: {
                channel: {
                    id: teamsChannelId,
                },
            },
            activity,
            agent: context.activity.recipient,
        };
        let conversationReference;
        let newActivityId;
        if (appId && context.adapter instanceof agents_hosting_1.CloudAdapter) {
            await context.adapter.createConversationAsync(appId, agents_activity_1.Channels.Msteams, context.activity.serviceUrl, 'https://api.botframework.com', convoParams, async (turnContext) => {
                conversationReference = turnContext.activity.getConversationReference();
                newActivityId = turnContext.activity.id;
            });
        }
        else {
            // const connectorClient = context.adapter.createConnectorClient(
            //   context.activity.serviceUrl
            // )
            const connectorClient = context.turnState.get('connectorClient');
            const conversationResourceResponse = await connectorClient.createConversation(convoParams);
            conversationReference = context.activity.getConversationReference();
            conversationReference.conversation.id = conversationResourceResponse.id;
            newActivityId = conversationResourceResponse.activityId;
        }
        // @ts-ignore
        return [conversationReference, newActivityId];
    }
    /**
     * Gets the channels of a team.
     *
     * @param {TurnContext} context - The turn context.
     * @param {string} [teamId] - The team ID.
     * @returns {Promise<ChannelInfo[]>} - The list of channels.
     */
    static async getTeamChannels(context, teamId) {
        var _a;
        if (!teamId) {
            const teamsChannelData = (0, teamsChannelDataParser_1.parseTeamsChannelData)(context.activity.channelData);
            teamId = (_a = teamsChannelData.team) === null || _a === void 0 ? void 0 : _a.id;
        }
        if (!teamId) {
            throw agents_activity_1.ExceptionHelper.generateException(Error, errorHelper_1.Errors.TeamIdRequired);
        }
        return await this.getRestClient(context).fetchChannelList(teamId);
    }
    /**
     * Gets the paged members of a team or conversation.
     *
     * @param {TurnContext} context - The turn context.
     * @param {number} [pageSize] - The page size.
     * @param {string} [continuationToken] - The continuation token.
     * @returns {Promise<TeamsPagedMembersResult>} - The paged members result.
     */
    static async getPagedMembers(context, pageSize, continuationToken) {
        var _a;
        const teamsChannelData = (0, teamsChannelDataParser_1.parseTeamsChannelData)(context.activity.channelData);
        const teamId = (_a = teamsChannelData.team) === null || _a === void 0 ? void 0 : _a.id;
        if (teamId) {
            return await this.getPagedTeamMembers(context, teamId, pageSize, continuationToken);
        }
        else {
            const conversation = context.activity.conversation;
            const conversationId = conversation && conversation.id ? conversation.id : undefined;
            return this.getRestClient(context).getConversationPagedMember(conversationId, pageSize, continuationToken);
        }
    }
    /**
     * Gets a member of a team or conversation.
     *
     * @param {TurnContext} context - The turn context.
     * @param {string} userId - The user ID.
     * @returns {Promise<TeamsChannelAccount>} - The member information.
     */
    static async getMember(context, userId) {
        var _a;
        const teamsChannelData = (0, teamsChannelDataParser_1.parseTeamsChannelData)(context.activity.channelData);
        const teamId = (_a = teamsChannelData.team) === null || _a === void 0 ? void 0 : _a.id;
        if (teamId) {
            return await this.getTeamMember(context, teamId, userId);
        }
        else {
            const conversationId = context.activity.conversation.id;
            return await this.getMemberInternal(context, conversationId, userId);
        }
    }
    /**
     * Gets the paged members of a team.
     *
     * @param {TurnContext} context - The turn context.
     * @param {string} [teamId] - The team ID.
     * @param {number} [pageSize] - The page size.
     * @param {string} [continuationToken] - The continuation token.
     * @returns {Promise<TeamsPagedMembersResult>} - The paged members result.
     */
    static async getPagedTeamMembers(context, teamId, pageSize, continuationToken) {
        var _a;
        if (!teamId) {
            const teamsChannelData = (0, teamsChannelDataParser_1.parseTeamsChannelData)(context.activity.channelData);
            teamId = (_a = teamsChannelData.team) === null || _a === void 0 ? void 0 : _a.id;
        }
        if (!teamId) {
            throw agents_activity_1.ExceptionHelper.generateException(Error, errorHelper_1.Errors.TeamIdRequired);
        }
        const pagedResults = await this.getRestClient(context).getConversationPagedMember(teamId, pageSize, continuationToken);
        do {
            if (pagedResults.continuationToken) {
                const nextResults = await this.getRestClient(context).getConversationPagedMember(teamId, pageSize, pagedResults.continuationToken);
                pagedResults.members.push(...nextResults.members);
                pagedResults.continuationToken = nextResults.continuationToken;
            }
        } while (pagedResults.continuationToken);
        return pagedResults;
    }
    /**
     * Gets a member of a team.
     *
     * @param {TurnContext} context - The turn context.
     * @param {string} teamId - The team ID.
     * @param {string} userId - The user ID.
     * @returns {Promise<TeamsChannelAccount>} - The member information.
     */
    static async getTeamMember(context, teamId, userId) {
        return await this.getRestClient(context).getConversationMember(teamId, userId);
    }
    /**
     * Sends a meeting notification.
     *
     * @param {TurnContext} context - The turn context.
     * @param {MeetingNotification} notification - The meeting notification.
     * @param {string} [meetingId] - The meeting ID.
     * @returns {Promise<MeetingNotificationResponse>} - The meeting notification response.
     */
    static async sendMeetingNotification(context, notification, meetingId) {
        const activity = context.activity;
        if (meetingId == null) {
            const teamsChannelData = (0, teamsChannelDataParser_1.parseTeamsChannelData)(activity.channelData);
            // const meeting = teamsGetTeamMeetingInfo(activity)
            const meeting = teamsChannelData.meeting;
            meetingId = meeting === null || meeting === void 0 ? void 0 : meeting.id;
        }
        if (!meetingId) {
            throw agents_activity_1.ExceptionHelper.generateException(Error, errorHelper_1.Errors.MeetingIdRequired);
        }
        return await this.getRestClient(context).sendMeetingNotification(meetingId, notification);
    }
    /**
     * Sends a message to a list of users.
     *
     * @param {TurnContext} context - The turn context.
     * @param {Activity} activity - The activity to send.
     * @param {string} tenantId - The tenant ID.
     * @param {TeamsMember[]} members - The list of members.
     * @returns {Promise<BatchOperationResponse>} - The batch operation response.
     */
    static async sendMessageToListOfUsers(context, activity, tenantId, members) {
        if (!activity) {
            throw agents_activity_1.ExceptionHelper.generateException(Error, errorHelper_1.Errors.ActivityRequired);
        }
        if (!tenantId) {
            throw agents_activity_1.ExceptionHelper.generateException(Error, errorHelper_1.Errors.TenantIdRequired);
        }
        if (!members || members.length === 0) {
            throw agents_activity_1.ExceptionHelper.generateException(Error, errorHelper_1.Errors.MembersListRequired);
        }
        return await this.getRestClient(context).sendMessageToListOfUsers(activity, tenantId, members);
    }
    /**
     * Sends a message to all users in a tenant.
     *
     * @param {TurnContext} context - The turn context.
     * @param {Activity} activity - The activity to send.
     * @param {string} tenantId - The tenant ID.
     * @returns {Promise<BatchOperationResponse>} - The batch operation response.
     */
    static async sendMessageToAllUsersInTenant(context, activity, tenantId) {
        if (!activity) {
            throw agents_activity_1.ExceptionHelper.generateException(Error, errorHelper_1.Errors.ActivityRequired);
        }
        if (!tenantId) {
            throw agents_activity_1.ExceptionHelper.generateException(Error, errorHelper_1.Errors.TenantIdRequired);
        }
        return await this.getRestClient(context).sendMessageToAllUsersInTenant(activity, tenantId);
    }
    /**
     * Sends a message to all users in a team.
     *
     * @param {TurnContext} context - The turn context.
     * @param {Activity} activity - The activity to send.
     * @param {string} tenantId - The tenant ID.
     * @param {string} teamId - The team ID.
     * @returns {Promise<BatchOperationResponse>} - The batch operation response.
     */
    static async sendMessageToAllUsersInTeam(context, activity, tenantId, teamId) {
        if (!activity) {
            throw agents_activity_1.ExceptionHelper.generateException(Error, errorHelper_1.Errors.ActivityRequired);
        }
        if (!tenantId) {
            throw agents_activity_1.ExceptionHelper.generateException(Error, errorHelper_1.Errors.TenantIdRequired);
        }
        if (!teamId) {
            throw agents_activity_1.ExceptionHelper.generateException(Error, errorHelper_1.Errors.TeamIdRequired);
        }
        return await this.getRestClient(context).sendMessageToAllUsersInTeam(activity, tenantId, teamId);
    }
    /**
     * Sends a message to a list of channels.
     *
     * @param {TurnContext} context - The turn context.
     * @param {Activity} activity - The activity to send.
     * @param {string} tenantId - The tenant ID.
     * @param {TeamsMember[]} members - The list of members.
     * @returns {Promise<BatchOperationResponse>} - The batch operation response.
     */
    static async sendMessageToListOfChannels(context, activity, tenantId, members) {
        if (!activity) {
            throw agents_activity_1.ExceptionHelper.generateException(Error, errorHelper_1.Errors.ActivityRequired);
        }
        if (!tenantId) {
            throw agents_activity_1.ExceptionHelper.generateException(Error, errorHelper_1.Errors.TenantIdRequired);
        }
        if (!members || members.length === 0) {
            throw agents_activity_1.ExceptionHelper.generateException(Error, errorHelper_1.Errors.MembersListRequired);
        }
        return this.getRestClient(context).sendMessageToListOfChannels(activity, tenantId, members);
    }
    /**
     * Gets the operation state.
     *
     * @param {TurnContext} context - The turn context.
     * @param {string} operationId - The operation ID.
     * @returns {Promise<BatchOperationStateResponse>} - The operation state response.
     */
    static async getOperationState(context, operationId) {
        if (!operationId) {
            throw agents_activity_1.ExceptionHelper.generateException(Error, errorHelper_1.Errors.OperationIdRequired);
        }
        return await this.getRestClient(context).getOperationState(operationId);
    }
    /**
     * Gets the failed entries of an operation.
     *
     * @param {TurnContext} context - The turn context.
     * @param {string} operationId - The operation ID.
     * @returns {Promise<BatchFailedEntriesResponse>} - The failed entries response.
     */
    static async getFailedEntries(context, operationId) {
        if (!operationId) {
            throw agents_activity_1.ExceptionHelper.generateException(Error, errorHelper_1.Errors.OperationIdRequired);
        }
        return await this.getRestClient(context).getFailedEntries(operationId);
    }
    /**
     * Cancels an operation.
     *
     * @param {TurnContext} context - The turn context.
     * @param {string} operationId - The operation ID.
     * @returns {Promise<CancelOperationResponse>} - The cancel operation response.
     */
    static async cancelOperation(context, operationId) {
        if (!operationId) {
            throw agents_activity_1.ExceptionHelper.generateException(Error, errorHelper_1.Errors.OperationIdRequired);
        }
        return await this.getRestClient(context).cancelOperation(operationId);
    }
    static async getMemberInternal(context, conversationId, userId) {
        const connectorClient = context.turnState.get('connectorClient');
        return await connectorClient.getConversationMember(userId, conversationId);
    }
    static getRestClient(context) {
        const connectorClient = context.turnState.get('connectorClient');
        return new teamsConnectorClient_1.TeamsConnectorClient(connectorClient);
    }
}
exports.TeamsInfo = TeamsInfo;
//# sourceMappingURL=teamsInfo.js.map