{"version":3,"file":"signal-watcher.js","sources":["../src/lib/signal-watcher.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport type {ReactiveElement} from 'lit';\nimport {Signal} from 'signal-polyfill';\n\nexport interface SignalWatcher extends ReactiveElement {\n  _watcher?: Signal.subtle.Watcher;\n}\n\ninterface EffectOptions {\n  /**\n   * By default effects run after the element has updated. If `beforeUpdate`\n   * is set to `true`, the effect will run before the element updates.\n   */\n  beforeUpdate?: boolean;\n  /**\n   * By default, effects are automatically disposed when the element is\n   * disconnected. If `manualDispose` is set to `true`, the effect will not\n   * be automatically disposed, and you must call the returned function to\n   * dispose of the effect manually.\n   */\n  manualDispose?: boolean;\n}\n\nlet effectsPending = false;\nconst effectWatcher = new Signal.subtle.Watcher(() => {\n  if (effectsPending) {\n    return;\n  }\n  effectsPending = true;\n  queueMicrotask(() => {\n    effectsPending = false;\n    for (const signal of effectWatcher.getPending()) {\n      signal.get();\n    }\n    effectWatcher.watch();\n  });\n});\n\ninterface SignalWatcherApi {\n  updateEffect(fn: () => void, options?: EffectOptions): () => void;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Constructor<T = {}> = new (...args: any[]) => T;\n\ninterface SignalWatcherInterface extends SignalWatcher {}\ninterface SignalWatcherInternal extends SignalWatcher {\n  __forcingUpdate: boolean;\n  __performUpdateSignal?: Signal.Computed<void>;\n  requestUpdate(): void;\n  __queueEffects: () => void;\n}\n\nconst signalWatcherBrand: unique symbol = Symbol('SignalWatcherBrand');\n\n// Memory management: We need to ensure that we don't leak memory by creating a\n// reference cycle between an element and its watcher, which then it kept alive\n// by the signals it watches. To avoid this, we break the cycle by using a\n// WeakMap to store the watcher for each element, and a FinalizationRegistry to\n// clean up the watcher when the element is garbage collected.\nconst elementFinalizationRegistry =\n  new FinalizationRegistry<Signal.subtle.Watcher>((watcher) => {\n    watcher.unwatch(...Signal.subtle.introspectSources(watcher));\n  });\n\nconst elementForWatcher = new WeakMap<\n  Signal.subtle.Watcher,\n  SignalWatcherInternal\n>();\n\n/**\n * Adds the ability for a LitElement or other ReactiveElement class to\n * watch for access to signals during the update lifecycle and trigger a new\n * update when signals values change.\n */\nexport function SignalWatcher<T extends Constructor<ReactiveElement>>(Base: T) {\n  // Only apply the mixin once\n  if ((Base as typeof SignalWatcher)[signalWatcherBrand] === true) {\n    console.warn(\n      'SignalWatcher should not be applied to the same class more than once.'\n    );\n    return Base as T & Constructor<SignalWatcherApi>;\n  }\n\n  class SignalWatcher extends Base implements SignalWatcherInterface {\n    static [signalWatcherBrand]: true;\n\n    // @internal used in watch directive\n    _watcher?: Signal.subtle.Watcher;\n\n    /**\n     * Flushes effects in required order:\n     * 1. Before update effects\n     * 2. Perform update\n     * 3. Pending watches\n     * 4. After update effects\n     * */\n    private __flushEffects() {\n      const beforeEffects = [] as Signal.Computed<void>[];\n      const afterEffects = [] as Signal.Computed<void>[];\n      this.__effects.forEach((options, signal) => {\n        const list = options?.beforeUpdate ? beforeEffects : afterEffects;\n        list.push(signal);\n      });\n      const pendingWatches = this._watcher\n        ?.getPending()\n        .filter(\n          (signal) =>\n            signal !== this.__performUpdateSignal && !this.__effects.has(signal)\n        );\n      beforeEffects.forEach((signal) => signal.get());\n      this.__performUpdateSignal?.get();\n      pendingWatches!.forEach((signal) => signal.get());\n      afterEffects.forEach((signal) => signal.get());\n    }\n\n    // @ts-expect-error This method is called anonymously in a watcher function\n    private __queueEffects() {\n      if (this.isUpdatePending) {\n        return;\n      }\n      queueMicrotask(() => {\n        if (!this.isUpdatePending) {\n          this.__flushEffects();\n        }\n      });\n    }\n\n    private __watch() {\n      if (this._watcher !== undefined) {\n        return;\n      }\n      // We create a fresh computed instead of just re-using the existing one\n      // because of https://github.com/proposal-signals/signal-polyfill/issues/27\n      this.__performUpdateSignal = new Signal.Computed(() => {\n        this.__forceUpdateSignal.get();\n        super.performUpdate();\n      });\n      const watcher = (this._watcher = new Signal.subtle.Watcher(function (\n        this: Signal.subtle.Watcher\n      ) {\n        // All top-level references in this function body must either be `this`\n        // (the `watcher`) or a module global to prevent this closure from keeping\n        // the enclosing scopes alive, which would keep the element alive. So\n        // The only two references are `this` and `elementForWatcher`.\n        const el = elementForWatcher.get(this);\n        if (el === undefined) {\n          // The element was garbage collected, so we can stop watching.\n          return;\n        }\n        if (el.__forcingUpdate === false) {\n          const needsUpdate = new Set(this.getPending()).has(\n            el.__performUpdateSignal as Signal.Computed<void>\n          );\n          if (needsUpdate) {\n            el.requestUpdate();\n          } else {\n            el.__queueEffects();\n          }\n        }\n        this.watch();\n      }));\n      elementForWatcher.set(watcher, this as unknown as SignalWatcherInternal);\n      elementFinalizationRegistry.register(this, watcher);\n      watcher.watch(this.__performUpdateSignal);\n      watcher.watch(...Array.from(this.__effects).map(([signal]) => signal));\n    }\n\n    private __unwatch() {\n      if (this._watcher === undefined) {\n        return;\n      }\n      let keepAlive = false;\n      // We unwatch all signals that are not manually disposed, so that we don't\n      // keep the element alive by holding references to it.\n      this._watcher.unwatch(\n        ...Signal.subtle.introspectSources(this._watcher!).filter((signal) => {\n          const shouldUnwatch =\n            this.__effects.get(signal as Signal.Computed<void>)\n              ?.manualDispose !== true;\n          if (shouldUnwatch) {\n            this.__effects.delete(signal as Signal.Computed<void>);\n          }\n          keepAlive ||= !shouldUnwatch;\n          return shouldUnwatch;\n        })\n      );\n      if (!keepAlive) {\n        this.__performUpdateSignal = undefined;\n        this._watcher = undefined;\n        this.__effects.clear();\n      }\n    }\n\n    // list signals managing effects, stored with effect options.\n    private __effects = new Map<\n      Signal.Computed<void>,\n      EffectOptions | undefined\n    >();\n\n    /**\n     * Executes the provided callback function when any of the signals it\n     * accesses change. By default, the function is called after any pending\n     * element update. Set the `beforeUpdate` property to `true` to run the\n     * effect before the element updates. An effect is automatically disposed\n     * when the element is disconnected. Set the `manualDispose` property to\n     * `true` to prevent this. Call the returned function to manually dispose\n     * of the effect.\n     *\n     * @param callback\n     * @param options {beforeUpdate, manualDispose}\n     */\n    updateEffect(fn: () => void, options?: EffectOptions): () => void {\n      this.__watch();\n      const signal = new Signal.Computed(() => {\n        fn();\n      });\n      this._watcher!.watch(signal);\n      this.__effects.set(signal, options);\n      const beforeUpdate = options?.beforeUpdate ?? false;\n      // An untracked read is safer and all that it takes to\n      // tell the watcher to go.\n      if (beforeUpdate) {\n        Signal.subtle.untrack(() => signal.get());\n      } else {\n        this.updateComplete.then(() =>\n          Signal.subtle.untrack(() => signal.get())\n        );\n      }\n      return () => {\n        this.__effects.delete(signal);\n        this._watcher!.unwatch(signal);\n        if (this.isConnected === false) {\n          this.__unwatch();\n        }\n      };\n    }\n\n    /**\n     * Used to force an uncached read of the __performUpdateSignal when we need\n     * to read the current value during an update.\n     *\n     * If https://github.com/tc39/proposal-signals/issues/151 is resolved, we\n     * won't need this.\n     */\n    private __forceUpdateSignal = new Signal.State(0);\n\n    /*\n     * This field is used within the watcher to determine if the watcher\n     * notification was triggered by our performUpdate() override. Because we\n     * force a fresh read of the __performUpdateSignal by changing value of the\n     * __forceUpdate signal, the watcher will be notified. But we're already\n     * performing an update, so we don't want to enqueue another one.\n     */\n    // @ts-expect-error This field is accessed in a watcher function with a\n    // different `this` context, so TypeScript can't see the access.\n    private __forcingUpdate = false;\n\n    /**\n     * A computed signal that wraps performUpdate() so that all signals that are\n     * accessed during the update lifecycle are tracked.\n     *\n     * __forceUpdateSignal is used to force an uncached read of this signal\n     * because updates may easily depend on non-signal values, so we must always\n     * re-run it.\n     */\n    private __performUpdateSignal?: Signal.Computed<void>;\n\n    protected override performUpdate() {\n      if (!this.isUpdatePending) {\n        // super.performUpdate() performs this check, so we bail early so that\n        // we don't read the __performUpdateSignal when it's not going to access\n        // any signals. This keeps the last signals read as the sources so that\n        // we'll get notified of changes to them.\n        return;\n      }\n      // Always enable watching before an update, even if disconnected, so that\n      // we can track signals that are accessed during the update.\n      this.__watch();\n      // Force an uncached read of __performUpdateSignal\n      this.__forcingUpdate = true;\n      this.__forceUpdateSignal.set(this.__forceUpdateSignal.get() + 1);\n      this.__forcingUpdate = false;\n      // Flush all queued effects...\n      this.__flushEffects();\n    }\n\n    override connectedCallback(): void {\n      super.connectedCallback();\n      // Because we might have missed some signal updates while disconnected,\n      // we force a full render on the next update.\n      this.requestUpdate();\n    }\n\n    override disconnectedCallback(): void {\n      super.disconnectedCallback();\n      // Clean up the watcher earlier than the FinalizationRegistry will, to\n      // avoid memory pressure from signals holding references to the element\n      // via the watcher.\n      //\n      // This means that while disconnected, regular reactive property updates\n      // will trigger a re-render, but signal updates will not. To ensure that\n      // current signal usage is still correctly tracked, we re-enable watching\n      // in performUpdate() even while disconnected. From that point on, a\n      // disconnected element will be retained by the signals it accesses during\n      // the update lifecycle.\n      //\n      // We use queueMicrotask() to ensure that this cleanup does not happen\n      // because of moves in the DOM within the same task, such as removing an\n      // element with .remove() and then adding it back later with .append()\n      // in the same task. For example, repeat() works this way.\n      queueMicrotask(() => {\n        if (this.isConnected === false) {\n          this.__unwatch();\n        }\n      });\n    }\n  }\n\n  return SignalWatcher as T & Constructor<SignalWatcherApi>;\n}\n"],"names":["effectsPending","effectWatcher","Signal","subtle","Watcher","queueMicrotask","signal","getPending","get","watch","signalWatcherBrand","Symbol","elementFinalizationRegistry","FinalizationRegistry","watcher","unwatch","introspectSources","elementForWatcher","WeakMap","SignalWatcher","Base","console","warn","constructor","this","__effects","Map","__forceUpdateSignal","State","__forcingUpdate","__flushEffects","beforeEffects","afterEffects","forEach","options","beforeUpdate","push","pendingWatches","_a","_watcher","filter","__performUpdateSignal","has","_b","__queueEffects","isUpdatePending","__watch","undefined","Computed","super","performUpdate","el","Set","requestUpdate","set","register","Array","from","map","__unwatch","keepAlive","shouldUnwatch","manualDispose","delete","clear","updateEffect","fn","untrack","updateComplete","then","isConnected","connectedCallback","disconnectedCallback"],"mappings":"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"}