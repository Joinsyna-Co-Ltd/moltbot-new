{"version":3,"file":"watch.js","sourceRoot":"","sources":["../../src/lib/watch.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {DirectiveResult, Part, directive} from 'lit/directive.js';\nimport {AsyncDirective} from 'lit/async-directive.js';\nimport {Signal} from 'signal-polyfill';\nimport {SignalWatcher} from './signal-watcher.js';\n\n// Watcher for directives that are not associated with a host element.\nlet effectsPending = false;\nconst hostlessWatcher = new Signal.subtle.Watcher(async () => {\n  if (effectsPending) {\n    return;\n  }\n  effectsPending = true;\n  queueMicrotask(() => {\n    effectsPending = false;\n    for (const signal of hostlessWatcher.getPending()) {\n      signal.get();\n    }\n    hostlessWatcher.watch();\n  });\n});\n\nexport class WatchDirective<T> extends AsyncDirective {\n  private __host?: SignalWatcher;\n\n  private __signal?: Signal.State<T> | Signal.Computed<T>;\n\n  private __watcher?: Signal.subtle.Watcher;\n\n  private __computed: Signal.Computed<T | undefined> | undefined;\n\n  private __watch() {\n    if (this.__watcher !== undefined) {\n      return;\n    }\n    this.__computed = new Signal.Computed(() => {\n      const value = this.__signal?.get();\n      this.setValue(value);\n      return value;\n    });\n    this.__watcher = this.__host?._watcher ?? hostlessWatcher;\n    this.__watcher.watch(this.__computed);\n    // get to trigger watcher but untracked so it's not part of performUpdate\n    Signal.subtle.untrack(() => this.__computed?.get());\n  }\n\n  private __unwatch() {\n    if (this.__watcher !== undefined) {\n      this.__watcher.unwatch(this.__signal!);\n      this.__watcher = undefined;\n    }\n  }\n\n  render(signal: Signal.State<T> | Signal.Computed<T>): T {\n    // This would only be called if render is called directly, like in SSR.\n    return Signal.subtle.untrack(() => signal.get());\n  }\n\n  override update(\n    part: Part,\n    [signal]: [signal: Signal.State<T> | Signal.Computed<T>]\n  ) {\n    this.__host ??= part.options?.host as SignalWatcher;\n    if (signal !== this.__signal && this.__signal !== undefined) {\n      // Unwatch the old signal\n      this.__unwatch();\n    }\n    this.__signal = signal;\n    this.__watch();\n    // We use untrack() so that the signal access is not tracked by the watcher\n    // created by SignalWatcher. This means that an can use both SignalWatcher\n    // and watch() and a signal update won't trigger a full element update if\n    // it's only passed to watch() and not otherwise accessed by the element.\n    return Signal.subtle.untrack(() => this.__signal!.get());\n  }\n\n  protected override disconnected(): void {\n    this.__unwatch();\n  }\n\n  protected override reconnected(): void {\n    this.__watch();\n  }\n}\n\nexport type WatchDirectiveFunction = <T>(\n  signal: Signal.State<T> | Signal.Computed<T>\n) => DirectiveResult<typeof WatchDirective<T>>;\n\n/**\n * Renders a signal and subscribes to it, updating the part when the signal\n * changes.\n *\n * watch() can only be used in a reactive element that applies the\n * SignalWatcher mixin.\n */\nexport const watch = directive(WatchDirective) as WatchDirectiveFunction;\n"]}