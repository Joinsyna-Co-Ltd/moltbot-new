{"version":3,"file":"signal-watcher.js","sourceRoot":"","sources":["../../src/lib/signal-watcher.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAGH,OAAO,EAAC,MAAM,EAAC,MAAM,iBAAiB,CAAC;AAqBvC,IAAI,cAAc,GAAG,KAAK,CAAC;AAC3B,MAAM,aAAa,GAAG,IAAI,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE;IACnD,IAAI,cAAc,EAAE,CAAC;QACnB,OAAO;IACT,CAAC;IACD,cAAc,GAAG,IAAI,CAAC;IACtB,cAAc,CAAC,GAAG,EAAE;QAClB,cAAc,GAAG,KAAK,CAAC;QACvB,KAAK,MAAM,MAAM,IAAI,aAAa,CAAC,UAAU,EAAE,EAAE,CAAC;YAChD,MAAM,CAAC,GAAG,EAAE,CAAC;QACf,CAAC;QACD,aAAa,CAAC,KAAK,EAAE,CAAC;IACxB,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC;AAiBH,MAAM,kBAAkB,GAAkB,MAAM,CAAC,oBAAoB,CAAC,CAAC;AAEvE,+EAA+E;AAC/E,+EAA+E;AAC/E,0EAA0E;AAC1E,+EAA+E;AAC/E,8DAA8D;AAC9D,MAAM,2BAA2B,GAC/B,IAAI,oBAAoB,CAAwB,CAAC,OAAO,EAAE,EAAE;IAC1D,OAAO,CAAC,OAAO,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC,CAAC;AAC/D,CAAC,CAAC,CAAC;AAEL,MAAM,iBAAiB,GAAG,IAAI,OAAO,EAGlC,CAAC;AAEJ;;;;GAIG;AACH,MAAM,UAAU,aAAa,CAAyC,IAAO;IAC3E,4BAA4B;IAC5B,IAAK,IAA6B,CAAC,kBAAkB,CAAC,KAAK,IAAI,EAAE,CAAC;QAChE,OAAO,CAAC,IAAI,CACV,uEAAuE,CACxE,CAAC;QACF,OAAO,IAAyC,CAAC;IACnD,CAAC;IAED,MAAM,aAAc,SAAQ,IAAI;QAAhC;;YA8GE,6DAA6D;YACrD,cAAS,GAAG,IAAI,GAAG,EAGxB,CAAC;YAwCJ;;;;;;eAMG;YACK,wBAAmB,GAAG,IAAI,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YAElD;;;;;;eAMG;YACH,uEAAuE;YACvE,gEAAgE;YACxD,oBAAe,GAAG,KAAK,CAAC;QA6DlC,CAAC;QAnOC;;;;;;aAMK;QACG,cAAc;;YACpB,MAAM,aAAa,GAAG,EAA6B,CAAC;YACpD,MAAM,YAAY,GAAG,EAA6B,CAAC;YACnD,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;gBACzC,MAAM,IAAI,GAAG,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,YAAY,EAAC,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,YAAY,CAAC;gBAClE,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACpB,CAAC,CAAC,CAAC;YACH,MAAM,cAAc,GAAG,MAAA,IAAI,CAAC,QAAQ,0CAChC,UAAU,GACX,MAAM,CACL,CAAC,MAAM,EAAE,EAAE,CACT,MAAM,KAAK,IAAI,CAAC,qBAAqB,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,CACvE,CAAC;YACJ,aAAa,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC;YAChD,MAAA,IAAI,CAAC,qBAAqB,0CAAE,GAAG,EAAE,CAAC;YAClC,cAAe,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC;YAClD,YAAY,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC;QACjD,CAAC;QAED,2EAA2E;QACnE,cAAc;YACpB,IAAI,IAAI,CAAC,eAAe,EAAE,CAAC;gBACzB,OAAO;YACT,CAAC;YACD,cAAc,CAAC,GAAG,EAAE;gBAClB,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE,CAAC;oBAC1B,IAAI,CAAC,cAAc,EAAE,CAAC;gBACxB,CAAC;YACH,CAAC,CAAC,CAAC;QACL,CAAC;QAEO,OAAO;YACb,IAAI,IAAI,CAAC,QAAQ,KAAK,SAAS,EAAE,CAAC;gBAChC,OAAO;YACT,CAAC;YACD,uEAAuE;YACvE,2EAA2E;YAC3E,IAAI,CAAC,qBAAqB,GAAG,IAAI,MAAM,CAAC,QAAQ,CAAC,GAAG,EAAE;gBACpD,IAAI,CAAC,mBAAmB,CAAC,GAAG,EAAE,CAAC;gBAC/B,KAAK,CAAC,aAAa,EAAE,CAAC;YACxB,CAAC,CAAC,CAAC;YACH,MAAM,OAAO,GAAG,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC;gBAGzD,uEAAuE;gBACvE,0EAA0E;gBAC1E,qEAAqE;gBACrE,8DAA8D;gBAC9D,MAAM,EAAE,GAAG,iBAAiB,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;gBACvC,IAAI,EAAE,KAAK,SAAS,EAAE,CAAC;oBACrB,8DAA8D;oBAC9D,OAAO;gBACT,CAAC;gBACD,IAAI,EAAE,CAAC,eAAe,KAAK,KAAK,EAAE,CAAC;oBACjC,MAAM,WAAW,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC,CAAC,GAAG,CAChD,EAAE,CAAC,qBAA8C,CAClD,CAAC;oBACF,IAAI,WAAW,EAAE,CAAC;wBAChB,EAAE,CAAC,aAAa,EAAE,CAAC;oBACrB,CAAC;yBAAM,CAAC;wBACN,EAAE,CAAC,cAAc,EAAE,CAAC;oBACtB,CAAC;gBACH,CAAC;gBACD,IAAI,CAAC,KAAK,EAAE,CAAC;YACf,CAAC,CAAC,CAAC,CAAC;YACJ,iBAAiB,CAAC,GAAG,CAAC,OAAO,EAAE,IAAwC,CAAC,CAAC;YACzE,2BAA2B,CAAC,QAAQ,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;YACpD,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,qBAAqB,CAAC,CAAC;YAC1C,OAAO,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC;QACzE,CAAC;QAEO,SAAS;YACf,IAAI,IAAI,CAAC,QAAQ,KAAK,SAAS,EAAE,CAAC;gBAChC,OAAO;YACT,CAAC;YACD,IAAI,SAAS,GAAG,KAAK,CAAC;YACtB,0EAA0E;YAC1E,sDAAsD;YACtD,IAAI,CAAC,QAAQ,CAAC,OAAO,CACnB,GAAG,MAAM,CAAC,MAAM,CAAC,iBAAiB,CAAC,IAAI,CAAC,QAAS,CAAC,CAAC,MAAM,CAAC,CAAC,MAAM,EAAE,EAAE;;gBACnE,MAAM,aAAa,GACjB,CAAA,MAAA,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAA+B,CAAC,0CAC/C,aAAa,MAAK,IAAI,CAAC;gBAC7B,IAAI,aAAa,EAAE,CAAC;oBAClB,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,MAA+B,CAAC,CAAC;gBACzD,CAAC;gBACD,SAAS,KAAT,SAAS,GAAK,CAAC,aAAa,EAAC;gBAC7B,OAAO,aAAa,CAAC;YACvB,CAAC,CAAC,CACH,CAAC;YACF,IAAI,CAAC,SAAS,EAAE,CAAC;gBACf,IAAI,CAAC,qBAAqB,GAAG,SAAS,CAAC;gBACvC,IAAI,CAAC,QAAQ,GAAG,SAAS,CAAC;gBAC1B,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC;YACzB,CAAC;QACH,CAAC;QAQD;;;;;;;;;;;WAWG;QACH,YAAY,CAAC,EAAc,EAAE,OAAuB;;YAClD,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,MAAM,MAAM,GAAG,IAAI,MAAM,CAAC,QAAQ,CAAC,GAAG,EAAE;gBACtC,EAAE,EAAE,CAAC;YACP,CAAC,CAAC,CAAC;YACH,IAAI,CAAC,QAAS,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;YAC7B,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;YACpC,MAAM,YAAY,GAAG,MAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,YAAY,mCAAI,KAAK,CAAC;YACpD,sDAAsD;YACtD,0BAA0B;YAC1B,IAAI,YAAY,EAAE,CAAC;gBACjB,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC;YAC5C,CAAC;iBAAM,CAAC;gBACN,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,EAAE,CAC5B,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,CAC1C,CAAC;YACJ,CAAC;YACD,OAAO,GAAG,EAAE;gBACV,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;gBAC9B,IAAI,CAAC,QAAS,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;gBAC/B,IAAI,IAAI,CAAC,WAAW,KAAK,KAAK,EAAE,CAAC;oBAC/B,IAAI,CAAC,SAAS,EAAE,CAAC;gBACnB,CAAC;YACH,CAAC,CAAC;QACJ,CAAC;QAgCkB,aAAa;YAC9B,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE,CAAC;gBAC1B,sEAAsE;gBACtE,wEAAwE;gBACxE,uEAAuE;gBACvE,yCAAyC;gBACzC,OAAO;YACT,CAAC;YACD,yEAAyE;YACzE,4DAA4D;YAC5D,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,kDAAkD;YAClD,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC;YAC5B,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,IAAI,CAAC,mBAAmB,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;YACjE,IAAI,CAAC,eAAe,GAAG,KAAK,CAAC;YAC7B,8BAA8B;YAC9B,IAAI,CAAC,cAAc,EAAE,CAAC;QACxB,CAAC;QAEQ,iBAAiB;YACxB,KAAK,CAAC,iBAAiB,EAAE,CAAC;YAC1B,uEAAuE;YACvE,6CAA6C;YAC7C,IAAI,CAAC,aAAa,EAAE,CAAC;QACvB,CAAC;QAEQ,oBAAoB;YAC3B,KAAK,CAAC,oBAAoB,EAAE,CAAC;YAC7B,sEAAsE;YACtE,uEAAuE;YACvE,mBAAmB;YACnB,EAAE;YACF,wEAAwE;YACxE,wEAAwE;YACxE,yEAAyE;YACzE,oEAAoE;YACpE,0EAA0E;YAC1E,wBAAwB;YACxB,EAAE;YACF,sEAAsE;YACtE,wEAAwE;YACxE,sEAAsE;YACtE,0DAA0D;YAC1D,cAAc,CAAC,GAAG,EAAE;gBAClB,IAAI,IAAI,CAAC,WAAW,KAAK,KAAK,EAAE,CAAC;oBAC/B,IAAI,CAAC,SAAS,EAAE,CAAC;gBACnB,CAAC;YACH,CAAC,CAAC,CAAC;QACL,CAAC;KACF;IAED,OAAO,aAAkD,CAAC;AAC5D,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport type {ReactiveElement} from 'lit';\nimport {Signal} from 'signal-polyfill';\n\nexport interface SignalWatcher extends ReactiveElement {\n  _watcher?: Signal.subtle.Watcher;\n}\n\ninterface EffectOptions {\n  /**\n   * By default effects run after the element has updated. If `beforeUpdate`\n   * is set to `true`, the effect will run before the element updates.\n   */\n  beforeUpdate?: boolean;\n  /**\n   * By default, effects are automatically disposed when the element is\n   * disconnected. If `manualDispose` is set to `true`, the effect will not\n   * be automatically disposed, and you must call the returned function to\n   * dispose of the effect manually.\n   */\n  manualDispose?: boolean;\n}\n\nlet effectsPending = false;\nconst effectWatcher = new Signal.subtle.Watcher(() => {\n  if (effectsPending) {\n    return;\n  }\n  effectsPending = true;\n  queueMicrotask(() => {\n    effectsPending = false;\n    for (const signal of effectWatcher.getPending()) {\n      signal.get();\n    }\n    effectWatcher.watch();\n  });\n});\n\ninterface SignalWatcherApi {\n  updateEffect(fn: () => void, options?: EffectOptions): () => void;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Constructor<T = {}> = new (...args: any[]) => T;\n\ninterface SignalWatcherInterface extends SignalWatcher {}\ninterface SignalWatcherInternal extends SignalWatcher {\n  __forcingUpdate: boolean;\n  __performUpdateSignal?: Signal.Computed<void>;\n  requestUpdate(): void;\n  __queueEffects: () => void;\n}\n\nconst signalWatcherBrand: unique symbol = Symbol('SignalWatcherBrand');\n\n// Memory management: We need to ensure that we don't leak memory by creating a\n// reference cycle between an element and its watcher, which then it kept alive\n// by the signals it watches. To avoid this, we break the cycle by using a\n// WeakMap to store the watcher for each element, and a FinalizationRegistry to\n// clean up the watcher when the element is garbage collected.\nconst elementFinalizationRegistry =\n  new FinalizationRegistry<Signal.subtle.Watcher>((watcher) => {\n    watcher.unwatch(...Signal.subtle.introspectSources(watcher));\n  });\n\nconst elementForWatcher = new WeakMap<\n  Signal.subtle.Watcher,\n  SignalWatcherInternal\n>();\n\n/**\n * Adds the ability for a LitElement or other ReactiveElement class to\n * watch for access to signals during the update lifecycle and trigger a new\n * update when signals values change.\n */\nexport function SignalWatcher<T extends Constructor<ReactiveElement>>(Base: T) {\n  // Only apply the mixin once\n  if ((Base as typeof SignalWatcher)[signalWatcherBrand] === true) {\n    console.warn(\n      'SignalWatcher should not be applied to the same class more than once.'\n    );\n    return Base as T & Constructor<SignalWatcherApi>;\n  }\n\n  class SignalWatcher extends Base implements SignalWatcherInterface {\n    static [signalWatcherBrand]: true;\n\n    // @internal used in watch directive\n    _watcher?: Signal.subtle.Watcher;\n\n    /**\n     * Flushes effects in required order:\n     * 1. Before update effects\n     * 2. Perform update\n     * 3. Pending watches\n     * 4. After update effects\n     * */\n    private __flushEffects() {\n      const beforeEffects = [] as Signal.Computed<void>[];\n      const afterEffects = [] as Signal.Computed<void>[];\n      this.__effects.forEach((options, signal) => {\n        const list = options?.beforeUpdate ? beforeEffects : afterEffects;\n        list.push(signal);\n      });\n      const pendingWatches = this._watcher\n        ?.getPending()\n        .filter(\n          (signal) =>\n            signal !== this.__performUpdateSignal && !this.__effects.has(signal)\n        );\n      beforeEffects.forEach((signal) => signal.get());\n      this.__performUpdateSignal?.get();\n      pendingWatches!.forEach((signal) => signal.get());\n      afterEffects.forEach((signal) => signal.get());\n    }\n\n    // @ts-expect-error This method is called anonymously in a watcher function\n    private __queueEffects() {\n      if (this.isUpdatePending) {\n        return;\n      }\n      queueMicrotask(() => {\n        if (!this.isUpdatePending) {\n          this.__flushEffects();\n        }\n      });\n    }\n\n    private __watch() {\n      if (this._watcher !== undefined) {\n        return;\n      }\n      // We create a fresh computed instead of just re-using the existing one\n      // because of https://github.com/proposal-signals/signal-polyfill/issues/27\n      this.__performUpdateSignal = new Signal.Computed(() => {\n        this.__forceUpdateSignal.get();\n        super.performUpdate();\n      });\n      const watcher = (this._watcher = new Signal.subtle.Watcher(function (\n        this: Signal.subtle.Watcher\n      ) {\n        // All top-level references in this function body must either be `this`\n        // (the `watcher`) or a module global to prevent this closure from keeping\n        // the enclosing scopes alive, which would keep the element alive. So\n        // The only two references are `this` and `elementForWatcher`.\n        const el = elementForWatcher.get(this);\n        if (el === undefined) {\n          // The element was garbage collected, so we can stop watching.\n          return;\n        }\n        if (el.__forcingUpdate === false) {\n          const needsUpdate = new Set(this.getPending()).has(\n            el.__performUpdateSignal as Signal.Computed<void>\n          );\n          if (needsUpdate) {\n            el.requestUpdate();\n          } else {\n            el.__queueEffects();\n          }\n        }\n        this.watch();\n      }));\n      elementForWatcher.set(watcher, this as unknown as SignalWatcherInternal);\n      elementFinalizationRegistry.register(this, watcher);\n      watcher.watch(this.__performUpdateSignal);\n      watcher.watch(...Array.from(this.__effects).map(([signal]) => signal));\n    }\n\n    private __unwatch() {\n      if (this._watcher === undefined) {\n        return;\n      }\n      let keepAlive = false;\n      // We unwatch all signals that are not manually disposed, so that we don't\n      // keep the element alive by holding references to it.\n      this._watcher.unwatch(\n        ...Signal.subtle.introspectSources(this._watcher!).filter((signal) => {\n          const shouldUnwatch =\n            this.__effects.get(signal as Signal.Computed<void>)\n              ?.manualDispose !== true;\n          if (shouldUnwatch) {\n            this.__effects.delete(signal as Signal.Computed<void>);\n          }\n          keepAlive ||= !shouldUnwatch;\n          return shouldUnwatch;\n        })\n      );\n      if (!keepAlive) {\n        this.__performUpdateSignal = undefined;\n        this._watcher = undefined;\n        this.__effects.clear();\n      }\n    }\n\n    // list signals managing effects, stored with effect options.\n    private __effects = new Map<\n      Signal.Computed<void>,\n      EffectOptions | undefined\n    >();\n\n    /**\n     * Executes the provided callback function when any of the signals it\n     * accesses change. By default, the function is called after any pending\n     * element update. Set the `beforeUpdate` property to `true` to run the\n     * effect before the element updates. An effect is automatically disposed\n     * when the element is disconnected. Set the `manualDispose` property to\n     * `true` to prevent this. Call the returned function to manually dispose\n     * of the effect.\n     *\n     * @param callback\n     * @param options {beforeUpdate, manualDispose}\n     */\n    updateEffect(fn: () => void, options?: EffectOptions): () => void {\n      this.__watch();\n      const signal = new Signal.Computed(() => {\n        fn();\n      });\n      this._watcher!.watch(signal);\n      this.__effects.set(signal, options);\n      const beforeUpdate = options?.beforeUpdate ?? false;\n      // An untracked read is safer and all that it takes to\n      // tell the watcher to go.\n      if (beforeUpdate) {\n        Signal.subtle.untrack(() => signal.get());\n      } else {\n        this.updateComplete.then(() =>\n          Signal.subtle.untrack(() => signal.get())\n        );\n      }\n      return () => {\n        this.__effects.delete(signal);\n        this._watcher!.unwatch(signal);\n        if (this.isConnected === false) {\n          this.__unwatch();\n        }\n      };\n    }\n\n    /**\n     * Used to force an uncached read of the __performUpdateSignal when we need\n     * to read the current value during an update.\n     *\n     * If https://github.com/tc39/proposal-signals/issues/151 is resolved, we\n     * won't need this.\n     */\n    private __forceUpdateSignal = new Signal.State(0);\n\n    /*\n     * This field is used within the watcher to determine if the watcher\n     * notification was triggered by our performUpdate() override. Because we\n     * force a fresh read of the __performUpdateSignal by changing value of the\n     * __forceUpdate signal, the watcher will be notified. But we're already\n     * performing an update, so we don't want to enqueue another one.\n     */\n    // @ts-expect-error This field is accessed in a watcher function with a\n    // different `this` context, so TypeScript can't see the access.\n    private __forcingUpdate = false;\n\n    /**\n     * A computed signal that wraps performUpdate() so that all signals that are\n     * accessed during the update lifecycle are tracked.\n     *\n     * __forceUpdateSignal is used to force an uncached read of this signal\n     * because updates may easily depend on non-signal values, so we must always\n     * re-run it.\n     */\n    private __performUpdateSignal?: Signal.Computed<void>;\n\n    protected override performUpdate() {\n      if (!this.isUpdatePending) {\n        // super.performUpdate() performs this check, so we bail early so that\n        // we don't read the __performUpdateSignal when it's not going to access\n        // any signals. This keeps the last signals read as the sources so that\n        // we'll get notified of changes to them.\n        return;\n      }\n      // Always enable watching before an update, even if disconnected, so that\n      // we can track signals that are accessed during the update.\n      this.__watch();\n      // Force an uncached read of __performUpdateSignal\n      this.__forcingUpdate = true;\n      this.__forceUpdateSignal.set(this.__forceUpdateSignal.get() + 1);\n      this.__forcingUpdate = false;\n      // Flush all queued effects...\n      this.__flushEffects();\n    }\n\n    override connectedCallback(): void {\n      super.connectedCallback();\n      // Because we might have missed some signal updates while disconnected,\n      // we force a full render on the next update.\n      this.requestUpdate();\n    }\n\n    override disconnectedCallback(): void {\n      super.disconnectedCallback();\n      // Clean up the watcher earlier than the FinalizationRegistry will, to\n      // avoid memory pressure from signals holding references to the element\n      // via the watcher.\n      //\n      // This means that while disconnected, regular reactive property updates\n      // will trigger a re-render, but signal updates will not. To ensure that\n      // current signal usage is still correctly tracked, we re-enable watching\n      // in performUpdate() even while disconnected. From that point on, a\n      // disconnected element will be retained by the signals it accesses during\n      // the update lifecycle.\n      //\n      // We use queueMicrotask() to ensure that this cleanup does not happen\n      // because of moves in the DOM within the same task, such as removing an\n      // element with .remove() and then adding it back later with .append()\n      // in the same task. For example, repeat() works this way.\n      queueMicrotask(() => {\n        if (this.isConnected === false) {\n          this.__unwatch();\n        }\n      });\n    }\n  }\n\n  return SignalWatcher as T & Constructor<SignalWatcherApi>;\n}\n"]}